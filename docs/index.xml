<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Simplified Semantic Data Modeling on S2DM</title>
    <link>http://localhost:1313/</link>
    <description>Recent content in Simplified Semantic Data Modeling on S2DM</description>
    <generator>Hugo</generator>
    <language>en</language>
    <atom:link href="http://localhost:1313/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Command Line Interface (CLI)</title>
      <link>http://localhost:1313/docs/tools/command-line-interface-cli/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/tools/command-line-interface-cli/</guid>
      <description>Under construction&amp;hellip;</description>
    </item>
    <item>
      <title>Automation</title>
      <link>http://localhost:1313/docs/tools/automation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/tools/automation/</guid>
      <description>Under construction&amp;hellip;</description>
    </item>
    <item>
      <title>Interactive GraphQL Schema Visualization</title>
      <link>http://localhost:1313/examples/test-voyager-copy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/examples/test-voyager-copy/</guid>
      <description>Interactive GraphQL Schema Visualization Explore the seat capabilities domain model through an interactive GraphQL Voyager visualization. This comprehensive schema, derived from the Vehicle Signal Specification (VSS) Seat branch, demonstrates how S2DM effectively models complex automotive domain relationships including nested components (backrest, headrest, seating), enumerated values, and rich type relationships.&#xA;Usage: Click and drag to navigate • Click types for details • Use the sidebar to search and explore documentation • Zoom with mouse wheel for different perspectives.</description>
    </item>
    <item>
      <title>Objects &amp; Fields</title>
      <link>http://localhost:1313/docs/approach-overview/objects-fields/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/approach-overview/objects-fields/</guid>
      <description>Under construction&amp;hellip;</description>
    </item>
    <item>
      <title>Pre-defined elements</title>
      <link>http://localhost:1313/docs/data-modeling-guideline/pre-defined-elements/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/data-modeling-guideline/pre-defined-elements/</guid>
      <description>Units Units are represented as enum values. For example:&#xA;enum VelocityUnitEnum { KILOMETER_PER_HOUR METERS_PER_SECOND }&#xD;The name of the enum itself refers to the quantity kind (e.g., Velocity). A set of commonly used units is provided in the file unit_enums.graphql.&#xA;It is planned to adopt and reuse an existing standard data model for units. See issue #43 for details.&#xA;Currently, the units file is inspired by the COVESA VSS Units file.</description>
    </item>
    <item>
      <title>Concept URIs</title>
      <link>http://localhost:1313/docs/approach-overview/concept-uris/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/approach-overview/concept-uris/</guid>
      <description>Under construction&amp;hellip;</description>
    </item>
    <item>
      <title>How to...?</title>
      <link>http://localhost:1313/docs/data-modeling-guideline/how-to.../</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/data-modeling-guideline/how-to.../</guid>
      <description>Under construction..&#xA;&amp;hellip;model an object and/or a field? Simply use the GraphQL SDL. Object types start with type keyword.&#xA;type MyObject { someField: String # &amp;lt;-- Built-in scalar as output anotherField: AnotherOutputType # &amp;lt;-- Custom named type as output }&#xD;Modeling Guide This document explains how to contribute to a specific model (new or existing).&#xA;If you want to contribute to the data modeling approach itself, see the Contributing Guide instead.</description>
    </item>
    <item>
      <title>Multi hierarchies</title>
      <link>http://localhost:1313/docs/approach-overview/multi-hierarchies/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/approach-overview/multi-hierarchies/</guid>
      <description>Under construction&amp;hellip;</description>
    </item>
    <item>
      <title>Variant IDs</title>
      <link>http://localhost:1313/docs/approach-overview/variant-ids/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/approach-overview/variant-ids/</guid>
      <description>Under construction..</description>
    </item>
    <item>
      <title>Specification registry</title>
      <link>http://localhost:1313/docs/approach-overview/specification-registry/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/approach-overview/specification-registry/</guid>
      <description>Under construction&amp;hellip;</description>
    </item>
    <item>
      <title>Capabilities</title>
      <link>http://localhost:1313/docs/approach-overview/capabilities/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/approach-overview/capabilities/</guid>
      <description>Under construction&amp;hellip;</description>
    </item>
    <item>
      <title>Version Bump CLI Examples</title>
      <link>http://localhost:1313/examples/version-bump-cli/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/examples/version-bump-cli/</guid>
      <description>This section contains examples demonstrating different scenarios for the s2dm check version-bump command, based on GraphQL Inspector&amp;rsquo;s change detection.&#xA;Overview The version-bump command analyzes GraphQL schema changes and recommends the appropriate semantic version bump:&#xA;No version bump: Identical schemas Patch/Minor bump: Non-breaking changes (new optional fields, enum values) Major bump: Breaking changes (removed fields, type changes) Dangerous changes: Potentially problematic but not immediately breaking Examples 1. No Version Bump Needed Command:</description>
    </item>
    <item>
      <title>Approach primer</title>
      <link>http://localhost:1313/others/approach_primer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/others/approach_primer/</guid>
      <description>Background Why do we need such an approach? Subject Matter Experts are often NOT data modeling experts Subject Matter Experts (SMEs) are often not familiar with data modeling, nor are they following best practices to formalize their knowledge. This lack in expertise can be problematic when they are in charge of expanding and maintaining a certain controlled vocabulary that will be used in real systems at the enterprise level.&#xA;Vehicle Signal Specification has been an alternative but requires improvements When it comes to vehicle data, the Vehicle Signal Specification (VSS) has been offering an easy-to-follow approach to enable SMEs contribute to a controlled vocabulary of high-level vehicle properties (e.</description>
    </item>
    <item>
      <title>Basic principle</title>
      <link>http://localhost:1313/others/basic_principle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/others/basic_principle/</guid>
      <description>Basic principle The idea is that multiple systems in the physical layer (e.g., databases, streaming platforms, applications, etc.) can share the same concepts. However, instead of arbitrarily modeling domains in the physical layer, the purpose is to have a unique way for specifying the concepts of common interest and its organizing principles in such a way that they are reused. This principle is a core part of a data-centric architecture, reducing undesired duplications and software waste when it is systematically applied.</description>
    </item>
  </channel>
</rss>
