[{"content":"Export Commands Naming Configuration All export commands support a global naming configuration feature that allows you to transform element names during the export process using the [--naming-config | -n] flag.\nApply naming configuration to any export command:\ns2dm export [--naming-config | -n] naming.yaml ...\rConfiguration Format The naming configuration is defined in a YAML file with the following structure:\n# Transform type names by type context type: object: PascalCase interface: PascalCase input: PascalCase enum: PascalCase union: PascalCase scalar: PascalCase # Transform field names by type context field: object: camelCase interface: camelCase input: snake_case # Transform enum values (no context needed) enumValue: MACROCASE # Transform instanceTag field names (no context needed) instanceTag: COBOL-CASE # Transform argument names by context argument: field: camelCase\rSupported Case Formats The naming configuration supports the following case conversion formats:\ncamelCase: myVariableName PascalCase: MyVariableName snake_case: my_variable_name kebab-case: my-variable-name MACROCASE: MY_VARIABLE_NAME COBOL-CASE: MY-VARIABLE-NAME flatcase: myvariablename TitleCase: My Variable Name Example Conversion Given this GraphQL schema:\ntype vehicle_info { avg_speed: Float fuel_type: fuel_type_enum } enum fuel_type_enum { GASOLINE_TYPE DIESEL_TYPE }\rAnd this naming configuration:\ntype: object: PascalCase enum: PascalCase field: object: camelCase enumValue: PascalCase\rThe exported schema will transform names as follows:\nType: vehicle_info → VehicleInfo Field: avg_speed → avgSpeed Field: fuel_type → fuelType Enum type: fuel_type_enum → FuelTypeEnum Enum values: GASOLINE_TYPE → GasolineType, DIESEL_TYPE → DieselType Validation Rules The naming configuration system enforces several validation rules to ensure consistency and correctness:\nElement Type Validation:\nValid element types: Only type, field, argument, enumValue, and instanceTag are allowed Context restrictions: Some element types cannot have context-specific configurations: enumValue and instanceTag are contextless and use a single case format argument can only have field context Value type validation: Element values must be either strings (case formats) or dictionaries (for context-specific configurations) Context Validation:\nType contexts: object, interface, input, scalar, union, enum Field contexts: object, interface, input Argument contexts: field Case Format Validation:\nValid case formats: camelCase, PascalCase, snake_case, kebab-case, MACROCASE, COBOL-CASE, flatcase, TitleCase Format enforcement: Only recognized case formats are accepted; invalid formats will cause validation errors Special Rules:\nEnumValue-InstanceTag pairing: If enumValue is present in the configuration, instanceTag must also be present InstanceTag preservation: The literal field name instanceTag is never transformed, regardless of naming configuration, to preserve its semantic meaning Notes Built-in GraphQL types (String, Int, Float, Boolean, ID, Query, Mutation, Subscription) are never transformed If a configuration is not provided for an element type, the original names are preserved Configuration is loaded once at the command level and applied consistently across the entire export process ","date":"0001-01-01","id":0,"permalink":"/docs/tools/command-line-interface-cli/","summary":"Export Commands Naming Configuration All export commands support a global naming configuration feature that allows you to transform element names during the export process using the [--naming-config | -n] flag.\nApply naming configuration to any export command:\ns2dm export [--naming-config | -n] naming.yaml ...\rConfiguration Format The naming configuration is defined in a YAML file with the following structure:\n# Transform type names by type context type: object: PascalCase interface: PascalCase input: PascalCase enum: PascalCase union: PascalCase scalar: PascalCase # Transform field names by type context field: object: camelCase interface: camelCase input: snake_case # Transform enum values (no context needed) enumValue: MACROCASE # Transform instanceTag field names (no context needed) instanceTag: COBOL-CASE # Transform argument names by context argument: field: camelCase\rSupported Case Formats The naming configuration supports the following case conversion formats:","tags":[],"title":"Command Line Interface (CLI)"},{"content":"Under construction\u0026hellip;\n","date":"0001-01-01","id":1,"permalink":"/docs/tools/automation/","summary":"Under construction\u0026hellip;","tags":[],"title":"Automation"},{"content":"Below are some examples of how the Simplified Semantic Data Modeling (S2DM) approach can be applied in different areas or use cases. Each example is linked to its corresponding folder in the repository for further exploration.\nExample Use Cases Seat domain model: Modeling the Seat branch of the Vehicle Signal Specification (VSS). Trailer domain model: Modeling the Trailer of a vehicle. Multiple Classification Schemes: Enabling multiple classification schemes using SKOS. Multiple Domains: Covering cross-references across different domains. Seat Capabilities: Specifying possible operations linked to seat-related objects or entities. Specification History Registry: Tracking changes and maintaining a registry of specification history. CLI Tool Examples Version Bump CLI Examples: Demonstrating automated version bumping based on GraphQL schema changes using the s2dm check version-bump command. If your use case is not covered by the presented examples, feel free to get in touch. If this approach suits your use case, we will add it here.\n","date":"0001-01-01","id":2,"permalink":"/examples/","summary":"Below are some examples of how the Simplified Semantic Data Modeling (S2DM) approach can be applied in different areas or use cases. Each example is linked to its corresponding folder in the repository for further exploration.\nExample Use Cases Seat domain model: Modeling the Seat branch of the Vehicle Signal Specification (VSS). Trailer domain model: Modeling the Trailer of a vehicle. Multiple Classification Schemes: Enabling multiple classification schemes using SKOS. Multiple Domains: Covering cross-references across different domains.","tags":[],"title":"Examples"},{"content":" Under construction\u0026hellip;\n","date":"0001-01-01","id":3,"permalink":"/docs/approach-overview/actively-developed-sme/","summary":"Under construction\u0026hellip;","tags":[],"title":"Actively Developed (SME)"},{"content":" ","date":"0001-01-01","id":4,"permalink":"/docs/approach-overview/","summary":" ","tags":[],"title":"Approach overview"},{"content":" Units Units are represented as enum values. For example:\nenum VelocityUnitEnum { KILOMETER_PER_HOUR METERS_PER_SECOND }\rThe name of the enum itself refers to the quantity kind (e.g., Velocity). A set of commonly used units is provided in the file unit_enums.graphql.\nIt is planned to adopt and reuse an existing standard data model for units. See issue #43 for details. Currently, the units file is inspired by the COVESA VSS Units file. The tentative model for future use is QUDT units.\nCustom scalars Scalars in GraphQL are basically the datatypes to which a field resolves. GraphQL supports a few built-in scalars such as Int, Float, String, Boolean, and ID. It is possible to define custom ones. The file /spec/custom_scalars.graphql contains custom scalars that could be referenced in the model.\nCustom directives @instanceTag directive @instanceTag on OBJECT\rTODO: Add description and example\n@cardinality directive @cardinality(min: Int, max: Int) on FIELD_DEFINITION\rTODO: Add description and example\n@range directive @range(min: Float, max: Float) on FIELD_DEFINITION\rTODO: Add description and example\n@noDuplicates directive @noDuplicates on FIELD_DEFINITION\rConsidering the following generic object:\ntype MyObject { field: \u0026lt;outputType\u0026gt; }\rBy default, the GraphQL SDL let us express the following six combinations for output types in fields:\nCase Description outputType Nullable Singular Field A singular element that can also be null. NamedType Non-Nullable Singular Field A singular element that cannot be null. NamedType! Nullable List Field An array of elements. The array itself can be null. [NamedType] Non-Nullable List Field An array of elements. The array itself cannot be null. [NamedType]! Nullable List of Non-Nullable Elements An array of elements. The array itself can be null but the elements cannot. [NamedType!] Non-Nullable List of Non-Nullable Elements List and elements in the list cannot be null. [NamedType!]! Implicitly, lists here refer to an array of values that could be duplicated. In order to explicitly say that the intended content of the array should function as a set of unique values instead, the custom directive @noDuplicates is introduced.\ntype Person { nicknamesList: [String] # Array with possible duplicate values nicknamesSet: [String] @noDuplicates # Set of unique values }\rCommon types Common enumeration sets In some cases, it is practical to refer to a particular set of values that might fit to multiple use cases. For example, the zone inside the cabin of a car could be re used by the Door and the Window It could be modeled as:\ntype InCabinZone { row: InCabinRowEnum! side: InCabinSide! } enum InCabinRowEnum { FRONT REAR } enum InCabinSide { DRIVER_SIDE PASSENGER_SIDE }\rThen, it can be referenced from:\nWindow { instance: InCabinZone ... } Door { instance: InCabinZone ... }\rSuch common enumeration sets are available in the file /spec/common_enums.graphql.\nCommon objects of interest Under construction\u0026hellip;\n","date":"0001-01-01","id":5,"permalink":"/docs/data-modeling-guideline/pre-defined-elements/","summary":"Units Units are represented as enum values. For example:\nenum VelocityUnitEnum { KILOMETER_PER_HOUR METERS_PER_SECOND }\rThe name of the enum itself refers to the quantity kind (e.g., Velocity). A set of commonly used units is provided in the file unit_enums.graphql.\nIt is planned to adopt and reuse an existing standard data model for units. See issue #43 for details. Currently, the units file is inspired by the COVESA VSS Units file.","tags":[],"title":"Pre-defined elements"},{"content":" Under construction\u0026hellip;\n","date":"0001-01-01","id":6,"permalink":"/docs/approach-overview/automated-ci-tooling/","summary":"Under construction\u0026hellip;","tags":[],"title":"Automated (CI Tooling)"},{"content":"Under construction\u0026hellip;\n","date":"0001-01-01","id":7,"permalink":"/docs/data-modeling-guideline/","summary":"Under construction\u0026hellip;","tags":[],"title":"Data modeling guideline"},{"content":"Under construction..\n\u0026hellip;model an object and/or a field? Simply use the GraphQL SDL. Object types start with type keyword.\ntype MyObject { someField: String # \u0026lt;-- Built-in scalar as output anotherField: AnotherOutputType # \u0026lt;-- Custom named type as output }\rModeling Guide This document explains how to contribute to a specific model (new or existing). If you want to contribute to the data modeling approach itself, see the Contributing Guide instead.\nTODO: Work in progress\u0026hellip;\nBasic building blocks We re use following established artifacts:\nFor the specification of data structures and possible operations on that data, S2DM re uses the GraphQL Schema Definition Language (SDL). The full feature set is available in the official GraphQL specification. For the specification of multiple classification schemes, S2DM uses the Simple Knowledge Organization System (SKOS). To learn more about them, please consult the official documentation. Modeling a new domain Identify the relevant object types (i.e., entities or classes). Examples: Vehicle, Person, etc. Specify an object type of each one (assuming it does not exist yet). Add fields to types to represent relationships. If the field resolves to a datatype, then assign an scalar. If the field connects to another object type, then assign it. Define the set of enum values. Add other metadata. Modeling an existing domain Extending an existing model Modifying an existing model Extending a type Deprecating elements It is possible to deprecate fields and enum values with the built-in directive @deprecated.\ntype Window { position: Int openness: Int @deprecated(reason: \u0026#34;Use `position`.\u0026#34;) }\rTo avoid breaking changes, GraphQL does not support the deprecation of types. To deprecate a complete type, simply deprecate all the fields or values inside.\ntype SomeDeprecatedObjectType { fieldOne: string @deprecated(reason: \u0026#34;Use `MyNewType.fieldOne`.\u0026#34;) ... fieldN: string @deprecated(reason: \u0026#34;Use `MyNewType.fieldN`.\u0026#34;) } type SomeDeprecatedEnum { ONE @deprecated(reason: \u0026#34;Use `MyNewEnum`.\u0026#34;) ... TEN @deprecated(reason: \u0026#34;Use `MyNewEnum`.\u0026#34;) }\rIf you want to know more, click here to see the specification.\nModel versioning This simplified modeling approach suggests the use of the GraphQL schema language as a mechanism to model concepts as a graph in a simple manner. It does not mean that one must implement a GraphQL server (there might be some advantages to do so, though). It is purely about the language and the community tools that exist. According to the official documentation of the language, versioning the schema is considered a bad practice.\nWhile there’s nothing that prevents a GraphQL service from being versioned just like any other API, GraphQL takes a strong opinion on avoiding versioning by providing the tools for the continuous evolution of a GraphQL schema\u0026hellip;\n\u0026hellip;GraphQL only returns the data that’s explicitly requested, so new capabilities can be added via new types or new fields on existing types without creating a breaking change. This has led to a common practice of always avoiding breaking changes and serving a versionless API.\nHowever, as the intention is to model a simple conceptual semantic model and not the full API itself, versioning is possible and special care must be given to the rule set.\nTODO: Work in progress\u0026hellip;\n","date":"0001-01-01","id":8,"permalink":"/docs/data-modeling-guideline/how-to.../","summary":"Under construction..\n\u0026hellip;model an object and/or a field? Simply use the GraphQL SDL. Object types start with type keyword.\ntype MyObject { someField: String # \u0026lt;-- Built-in scalar as output anotherField: AnotherOutputType # \u0026lt;-- Custom named type as output }\rModeling Guide This document explains how to contribute to a specific model (new or existing). If you want to contribute to the data modeling approach itself, see the Contributing Guide instead.","tags":[],"title":"How to...?"},{"content":"S2DM Documentation Welcome to the complete documentation for the Simplified Semantic Data Modeling (S2DM) approach. This documentation is organized into three main sections:\nDocumentation Sections The documentation is structured to guide you through understanding, implementing, and using S2DM:\nApproach Overview - Learn the fundamental concepts and principles of S2DM Data Modeling Guideline - Step-by-step guide to modeling your domain with S2DM Tools - Available tools and utilities to support your S2DM implementation Each section contains detailed information to help you effectively use the S2DM approach for your data modeling needs.\nS2DM artifacts are based on the following existing resources. Getting familiar with them is recommended.\nModeling languages and vocabularies\nGraphQL Schema Definition Language (SDL): Provides a clear, human-readable syntax for defining data structures and relationships, making it easy for SMEs to understand and use without requiring deep technical expertise. Simple Knowledge Organization System (SKOS): An RDF-based vocabulary that offers a straightforward framework for creating and managing hierarchical classifications and relationships between concepts, facilitating intuitive and semantically rich knowledge organization. Tools\nrdflib: For working with RDF data in Python (e.g., SKOS). graphql-core: For working with GraphQL schemas in Python (e.g., SDL). Others ","date":"0001-01-01","id":9,"permalink":"/docs/","summary":"S2DM Documentation Welcome to the complete documentation for the Simplified Semantic Data Modeling (S2DM) approach. This documentation is organized into three main sections:\nDocumentation Sections The documentation is structured to guide you through understanding, implementing, and using S2DM:\nApproach Overview - Learn the fundamental concepts and principles of S2DM Data Modeling Guideline - Step-by-step guide to modeling your domain with S2DM Tools - Available tools and utilities to support your S2DM implementation Each section contains detailed information to help you effectively use the S2DM approach for your data modeling needs.","tags":[],"title":"Documentation"},{"content":"Under construction\u0026hellip;\n","date":"0001-01-01","id":10,"permalink":"/docs/tools/","summary":"Under construction\u0026hellip;","tags":[],"title":"Tools"},{"content":" Under construction\u0026hellip;\n","date":"0001-01-01","id":11,"permalink":"/docs/approach-overview/optional-extensions-modelers/","summary":"Under construction\u0026hellip;","tags":[],"title":"Optional Extensions (Modelers)"},{"content":"This section contains examples demonstrating different scenarios for the s2dm check version-bump command, based on GraphQL Inspector\u0026rsquo;s change detection.\nOverview The version-bump command analyzes GraphQL schema changes and recommends the appropriate semantic version bump:\nNo version bump: Identical schemas Patch/Minor bump: Non-breaking changes (new optional fields, enum values) Major bump: Breaking changes (removed fields, type changes) Dangerous changes: Potentially problematic but not immediately breaking Examples 1. No Version Bump Needed Command:\ns2dm check version-bump -s no-change.graphql -p base.graphql\rExpected Output:\nNo version bump needed\rScenario: Both schemas are identical, no changes detected.\n2. Non-Breaking Change (Minor/Patch Bump) Command:\ns2dm check version-bump -s non-breaking.graphql -p base.graphql\rExpected Output:\nPatch version bump needed\rChanges:\nAdded new optional fields: Vehicle.owner, Vehicle.mileage, Engine.fuelEfficiency These changes are backwards compatible and won\u0026rsquo;t break existing clients.\n3. Dangerous Change Command:\ns2dm check version-bump -s dangerous.graphql -p base.graphql\rExpected Output:\nMinor version bump needed\rChanges:\nAdded new enum value: EngineType.HYDROGEN Note: GraphQL Inspector may classify these as dangerous changes depending on configuration, but they\u0026rsquo;re typically backwards compatible due to default values.\n4. Breaking Change (Major Bump) Command:\ns2dm check version-bump -s breaking.graphql -p base.graphql\rExpected Output:\nDetected breaking changes, major version bump needed. Please run diff to get more details\rChanges:\nRemoved field: Vehicle.color Changed field type: Vehicle.owner from String to Int Changed field type: Engine.displacement from Float to Int Removed enum value: EngineType.HYBRID These changes will break existing clients that depend on the removed/changed fields.\nUnderstanding Change Types Non-Breaking Changes ✅ Adding new optional fields Adding new enum values Adding new types Adding new queries/mutations Adding descriptions/deprecation notices Dangerous Changes ⚠️ Adding arguments to existing fields (with defaults) Changing field descriptions significantly Adding interfaces to existing types Breaking Changes ❌ Removing fields, types, or enum values Changing field types incompatibly Making optional fields required Removing or changing arguments Changing field nullability (nullable to non-nullable) Running the Examples To test these examples:\n# Navigate to the test data directory cd tests/data # Test each scenario s2dm check version-bump -s no-change.graphql -p base.graphql s2dm check version-bump -s non-breaking.graphql -p base.graphql s2dm check version-bump -s dangerous.graphql -p base.graphql s2dm check version-bump -s breaking.graphql -p base.graphql\rAdditional Commands For more detailed analysis, use the diff command:\ns2dm diff graphql -s breaking.graphql -v base.graphql\rThis will provide a comprehensive breakdown of all changes detected between the schemas.\nPipeline Usage For pipeline automation, use the --output-type flag to get machine-readable output:\n# Returns: none, patch, minor, or major VERSION_BUMP=$(s2dm check version-bump -s new-schema.graphql -p old-schema.graphql --output-type) # Example pipeline usage: if [[ \u0026#34;$VERSION_BUMP\u0026#34; == \u0026#34;major\u0026#34; ]]; then echo \u0026#34;Breaking changes detected, requires manual review\u0026#34; exit 1 elif [[ \u0026#34;$VERSION_BUMP\u0026#34; == \u0026#34;minor\u0026#34; ]]; then echo \u0026#34;Minor version bump needed\u0026#34; # bump-my-version bump minor elif [[ \u0026#34;$VERSION_BUMP\u0026#34; == \u0026#34;patch\u0026#34; ]]; then echo \u0026#34;Patch version bump needed\u0026#34; # bump-my-version bump patch else echo \u0026#34;No version bump needed\u0026#34; fi\rReturn Values none: No changes detected patch: Non-breaking changes only (✔ symbols in diff) minor: Dangerous changes detected (⚠ symbols in diff) major: Breaking changes detected (✖ symbols in diff) ","date":"0001-01-01","id":12,"permalink":"/examples/version-bump-cli/","summary":"This section contains examples demonstrating different scenarios for the s2dm check version-bump command, based on GraphQL Inspector\u0026rsquo;s change detection.\nOverview The version-bump command analyzes GraphQL schema changes and recommends the appropriate semantic version bump:\nNo version bump: Identical schemas Patch/Minor bump: Non-breaking changes (new optional fields, enum values) Major bump: Breaking changes (removed fields, type changes) Dangerous changes: Potentially problematic but not immediately breaking Examples 1. No Version Bump Needed Command:","tags":[],"title":"Version Bump CLI Examples"},{"content":"","date":"0001-01-01","id":13,"permalink":"/examples/test-voyager/","summary":"","tags":[],"title":""},{"content":"The Simplified Semantic Data Modeling (S2DM) is an approach for modeling data of multiple domains. It is simple in the sense that any Subject Matter Expert (SME) could contribute to a controlled vocabulary with minimal data modeling expertise. Likewise, it is semantic in the sense that it specifies meaningful data structures, their cross-domain relationships, and arbitrary classification schemes.\nBear in mind the word Simplified in the name. This approach aims to foster the adoption of (some) good data modeling practices. It does not intend to re-invent or replace long-standing standards, such as those of the Semantic Web. Therefore, it does not incorporate advanced reasoning capabilities or comprehensive ontologies typically associated with traditional semantic data modeling.\nThe figure above ilustrates the role of the S2DM approach. One can distinghish three areas: the re-use of existing resources (left), the artifacts offered by S2DM (center), and the resulting domain data model created and maintained with S2DM artifacts (right).\nS2DM artifacts are based on the following existing resources. Getting familiar with them is recommended.\nModeling languages and vocabularies\nGraphQL Schema Definition Language (SDL): Provides a clear, human-readable syntax for defining data structures and relationships, making it easy for SMEs to understand and use without requiring deep technical expertise. Simple Knowledge Organization System (SKOS): An RDF-based vocabulary that offers a straightforward framework for creating and managing hierarchical classifications and relationships between concepts, facilitating intuitive and semantically rich knowledge organization. Tools\nrdflib: For working with RDF data in Python (e.g., SKOS). graphql-core: For working with GraphQL schemas in Python (e.g., SDL). Additional dependencies ","date":"0001-01-01","id":14,"permalink":"/","summary":"The Simplified Semantic Data Modeling (S2DM) is an approach for modeling data of multiple domains. It is simple in the sense that any Subject Matter Expert (SME) could contribute to a controlled vocabulary with minimal data modeling expertise. Likewise, it is semantic in the sense that it specifies meaningful data structures, their cross-domain relationships, and arbitrary classification schemes.\nBear in mind the word Simplified in the name. This approach aims to foster the adoption of (some) good data modeling practices.","tags":[],"title":"Simplified Semantic Data Modeling"}]